<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>encukou/blog</title><link href="http://encukou.cz/" rel="alternate"></link><link href="http://encukou.cz/feeds/misc.atom.xml" rel="self"></link><id>http://encukou.cz/</id><updated>2015-10-25T00:00:00+02:00</updated><entry><title>First Layer Patterns with Slic3r Modifier Objects</title><link href="http://encukou.cz/blog/2015/10/25/en-slic3r-first-layer-patterns" rel="alternate"></link><updated>2015-10-25T00:00:00+02:00</updated><author><name>Petr Viktorin</name></author><id>tag:encukou.cz,2015-10-25:blog/2015/10/25/en-slic3r-first-layer-patterns</id><summary type="html">&lt;p&gt;I've built a&amp;nbsp;3D printer, and found a&amp;nbsp;cool effect I&amp;nbsp;wasn't able to
find on the Internet yet.&lt;/p&gt;


&lt;p&gt;&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/first-layer.jpg"&gt;&lt;img alt="What I'll be describing" class="size-auto" src="http://encukou.cz/../images/2015-10-25-slic3r/first-layer.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="my-setup"&gt;My Setup&lt;/h2&gt;
&lt;p&gt;I&amp;nbsp;haven't blogged about my 3D printer yet, so let's&amp;nbsp;quickly get that out
of the way.&lt;/p&gt;
&lt;p&gt;I&amp;nbsp;built a&amp;nbsp;modified &lt;a href="https://github.com/RepRap4U/RebeliX"&gt;RebeliX&lt;/a&gt; printer
at a&amp;nbsp;workshop.
(If you want to build a&amp;nbsp;printer, I'd really recommend you find a&amp;nbsp;workshop
nearby, rather than trying to figure out everything by yourself.
Tweaking something that already works is so much nicer than debugging an
unfamiliar system. And being able to ask experts anything is invaluable.)&lt;/p&gt;
&lt;p&gt;I&amp;nbsp;use Fedora's&amp;nbsp;3D printing stack (conveniently curated by my colleague
&lt;a href="http://hroncok.cz/"&gt;Miro Hrončok&lt;/a&gt;, who got me into this in the first place),
so it's&amp;nbsp;all nicely open-source and open-hardware.
The three main programs I&amp;nbsp;use are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://copr.fedoraproject.org/coprs/churchyard/openscad-devel/"&gt;OpenSCAD&lt;/a&gt;
  for modeling (going from idea to a&amp;nbsp;3D model on the screen)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://copr.fedoraproject.org/coprs/churchyard/slic3r-latest/"&gt;Slic3r&lt;/a&gt;
  for G-code generation (going from 3D to instructions for the printer)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/kliment/Printrun"&gt;Pronterface&lt;/a&gt; for printer control&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Today I'll be talking about the second tool in that chain.
But first, what will I&amp;nbsp;print?&lt;/p&gt;
&lt;h2 id="adrawer-handle"&gt;A&amp;nbsp;Drawer Handle&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/handle-old.jpg"&gt;&lt;img alt="The Problem" class="size-auto" src="http://encukou.cz/../images/2015-10-25-slic3r/handle-old.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I&amp;nbsp;have some drawers whose handles are pretty flimsy, and as time goes by,
they're detaching.
Which is a&amp;nbsp;shame, because these big, red handles fit my room really well.
And I&amp;nbsp;can't replace them, because nobody makes them anymore.
(Well, maybe they do – I&amp;nbsp;didn't look for them &lt;em&gt;everywhere&lt;/em&gt; – but the DYI
alternative is still more fun!)&lt;/p&gt;
&lt;p&gt;So, I&amp;nbsp;decided print handles! I'm designing a&amp;nbsp;handle that can take a&amp;nbsp;screw and
a&amp;nbsp;nut, so it should hold well.
At this point I'm still learning about prinitng objects with exact
measurements, so that part isn't really done.
What I &lt;em&gt;have&lt;/em&gt; done – perhaps prematurely – is the aesthetical&amp;nbsp;design.&lt;/p&gt;
&lt;h2 id="the-first-layer"&gt;The First Layer&lt;/h2&gt;
&lt;p&gt;Professionally printed things have a&amp;nbsp;smooth finish, where you can't see
the individual strands and layers that make up the object.
I'm sure with enouth calibration and &lt;a href="http://airwolf3d.com/2013/11/26/7-steps-shiny-finish-on-abs-parts-acetone/"&gt;finishing work&lt;/a&gt;
I&amp;nbsp;can achieve that with my printer as well, but for now, everyone can see my
objects come from an extruding printer&amp;nbsp;head.&lt;/p&gt;
&lt;p&gt;And I&amp;nbsp;like that! Not only me, several people I&amp;nbsp;showed the objects to liked
the pattern on the bottom, which is smooth and flat and smooth from lying
on the print bed, but still shows the path the extruder took.
As any good artist, I&amp;nbsp;get to take advantage of the imperfections
in my medium!&lt;/p&gt;
&lt;p&gt;The tool that generates the patterns for me, Slic3r, has
&lt;a href="http://manual.slic3r.org/expert-mode/infill"&gt;several to choose from&lt;/a&gt;.
Some are only available for the inside of objects, because they can't cover
100% of the space, but there's&amp;nbsp;still a&amp;nbsp;good selection: the boring old
Rectilinear, the outline-following Cocentric, the fractal Hilbert Curve,
the Archimedean Chords spiral, and the angular Octagram&amp;nbsp;Spiral.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/rectilinear.png"&gt;&lt;img alt="Plain Old Rectilinear" class="size-auto" src="http://encukou.cz/../images/2015-10-25-slic3r/rectilinear.png" /&gt;&lt;/a&gt;
&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/cocentric.png"&gt;&lt;img alt="Cocentric pattern" class="size-auto" src="http://encukou.cz/../images/2015-10-25-slic3r/cocentric.png" /&gt;&lt;/a&gt;
&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/hilbert.png"&gt;&lt;img alt="Hilbert Curve" class="size-auto" src="http://encukou.cz/../images/2015-10-25-slic3r/hilbert.png" /&gt;&lt;/a&gt;
&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/archimedean.png"&gt;&lt;img alt="Archimedean Chords" class="size-auto" src="http://encukou.cz/../images/2015-10-25-slic3r/archimedean.png" /&gt;&lt;/a&gt;
&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/octagram-spiral.png"&gt;&lt;img alt="Octagram Spiral" class="size-auto" src="http://encukou.cz/../images/2015-10-25-slic3r/octagram-spiral.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;They're mostly meant to be functional, but some are quite aesthetically
pleasing than others.
Being the geek that I&amp;nbsp;am, I&amp;nbsp;prefer the Archimedean Chords and
Hilbert Curve.
&lt;em&gt;(Octagram Spiral comes in at a&amp;nbsp;close third place, but if I&amp;nbsp;printed that I
would be worried about a&amp;nbsp;magic portal to Discworld suddenly opening. (I&amp;nbsp;wonder,
would that be a&amp;nbsp;bad thing? Anyway, where was I? Ah,
&lt;a href="https://en.wikipedia.org/wiki/Archimedes"&gt;Archimedes&lt;/a&gt; and
&lt;a href="https://en.wikipedia.org/wiki/David_Hilbert"&gt;Hilbert&lt;/a&gt;.))&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The trouble is, I&amp;nbsp;couldn't choose between the two.
Is there a&amp;nbsp;way to use both, I&amp;nbsp;wondered?&lt;/p&gt;
&lt;h2 id="modifier-objects"&gt;Modifier objects&lt;/h2&gt;
&lt;p&gt;Yes, there is!
At the workshop I&amp;nbsp;built my printer, the discussion wandered a&amp;nbsp;little too deep
into a&amp;nbsp;few obscure details that nobody really uses.
One of those is slic3r's&amp;nbsp;modifier meshes: a&amp;nbsp;way to change print settings
for a&amp;nbsp;specified part of the object.
There's&amp;nbsp;apparently only one documented use case for these on the Internet:
&lt;a href="http://slic3r.org/blog/modifier-meshes"&gt;strengthening the neck of an ukulele&lt;/a&gt;.
Let's&amp;nbsp;add another one!&lt;/p&gt;
&lt;p&gt;I&amp;nbsp;decided my new handles will be various regular polygons instead of
the original circles. I&amp;nbsp;decided to start with a&amp;nbsp;pentagon. To provide
some contrast to the geometric infill patterns, I&amp;nbsp;chose to include the
&lt;a href="https://en.wikipedia.org/wiki/Vinca_major"&gt;&lt;em&gt;Vinca major&lt;/em&gt;&lt;/a&gt;
&lt;a href="https://en.wikipedia.org/wiki/File:Apocynaceae_-_Vinca_major-1.JPG"&gt;flower&lt;/a&gt;
to the design.
Its five-fold rotational (but not reflectional) symmetry is quite&amp;nbsp;beautiful.&lt;/p&gt;
&lt;p&gt;I&amp;nbsp;traced a&amp;nbsp;petal in &lt;a href="https://inkscape.org"&gt;Inkcsape&lt;/a&gt;, and used
&lt;a href="http://www.thingiverse.com/thing:25036"&gt;a&amp;nbsp;plugin&lt;/a&gt; to generate a&amp;nbsp;very thin
3D model from it.
The thickness is about the same as the first layer of my printout.
Then, I&amp;nbsp;added the part as a&amp;nbsp;Modifier object in Slic3r, and set its infill
to Hilbert Curve. The rest of the object usess Archimedean&amp;nbsp;Chords.&lt;/p&gt;
&lt;p&gt;Et voilà! A&amp;nbsp;combined pattern&amp;nbsp;emerges.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/combination.png"&gt;&lt;img alt="Sliced bottom layer" class="size-full" src="http://encukou.cz/../images/2015-10-25-slic3r/combination.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Slic3r adds quite a&amp;nbsp;wide margin between the two areas, which works out well
for my use of two large patches of distinct textures.
If you want finer control, it might not be that&amp;nbsp;convenient.&lt;/p&gt;
&lt;h2 id="centering"&gt;Centering&lt;/h2&gt;
&lt;p&gt;Actually, there's&amp;nbsp;one more thing needed for a&amp;nbsp;nice result.
For patterns that have a&amp;nbsp;visible center (i.e. Octagram and the Archimedean Chords),
Slic3r seems to use the part's&amp;nbsp;bounding box to compute the&amp;nbsp;center.&lt;/p&gt;
&lt;p&gt;For the modifier object, this would be easy to fix: just add a&amp;nbsp;circle around
the flower, making it large enough to not intersect the handle&amp;nbsp;itself.&lt;/p&gt;
&lt;p&gt;For the actual handle, I&amp;nbsp;instead added little “specks” around the perimeter,
small enough to not be printed.
You can see them in the screnshot above as light grey dots off to the sides
of the pentagon.
This tricked Slic3r into putting the center where it should&amp;nbsp;be.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://encukou.cz/../images/2015-10-25-slic3r/handle-new.jpg"&gt;&lt;img alt="The Solution" class="size-auto" src="http://encukou.cz/../images/2015-10-25-slic3r/handle-new.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="to-be-continued"&gt;To Be Continued&lt;/h2&gt;
&lt;p&gt;Now that I&amp;nbsp;have the first layer ready, I'm off to making the screw &amp;amp; nut fit
well inside the handle.
And, of course, making similar designs for other polygons.
And printing other interesting things.
Maybe I'll blog about that as well!&lt;/p&gt;
&lt;p&gt;By the way, all the files for this project are &lt;a href="https://github.com/encukou/3d/tree/master/handle"&gt;on&amp;nbsp;Github&lt;/a&gt;.
Enjoy!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Oh, and if you want me to print anything: come visit me, bring some tea, and
we can chat while watching the printer make electronic noises and plastic
creations. (Otherwise, i&amp;nbsp;might add a&amp;nbsp;simple, small object to a&amp;nbsp;print job
if you send me a&amp;nbsp;fully prepared model, but you're probably better off ordering
a&amp;nbsp;print online.)&lt;/p&gt;</summary><category term="3d"></category></entry><entry><title>Types as namespaces</title><link href="http://encukou.cz/blog/2015/03/01/en-variable-types" rel="alternate"></link><updated>2015-03-01T00:00:00+01:00</updated><author><name>Petr Viktorin</name></author><id>tag:encukou.cz,2015-03-01:blog/2015/03/01/en-variable-types</id><summary type="html">&lt;p&gt;Musings inspired by Eevee's &lt;a href="http://eev.ee/blog/2015/02/28/sylph-the-programming-language-i-want/"&gt;post about Sylph&lt;/a&gt;.
Read that first.&lt;/p&gt;
&lt;p&gt;In Python's&amp;nbsp;duck-typing system, it's&amp;nbsp;enough if things quack.
They don't actually need to quack &lt;em&gt;like a&amp;nbsp;duck&lt;/em&gt;.&lt;/p&gt;


&lt;hr /&gt;
&lt;p&gt;Whenever you program, you need to keep track of the types of things you're dealing with.
Some languages – the statically typed ones – require you to specify the type in front, and then they check it rigorously.
In Python, you need to keep track of this in your head.
It's&amp;nbsp;possible that you're writing code where a&amp;nbsp;variable could be either a&amp;nbsp;string or a&amp;nbsp;number:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;def add(a, b):
    return a + b
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;... or you might want a&amp;nbsp;variable to changes type in the middle of a&amp;nbsp;function,
like in the example from &lt;a href="http://docs.python-guide.org/en/latest/writing/structure/#dynamic-typing"&gt;Hitchhiker's&amp;nbsp;guide to Python&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;items = &amp;#39;a b c d&amp;#39;  # This is a string...
items = items.split(&amp;#39; &amp;#39;)  # ...becoming a list
items = set(items)  # ...and then a set
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Those are smells: they should be &lt;em&gt;possible&lt;/em&gt; but not&amp;nbsp;&lt;em&gt;easy&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Variables (the &lt;em&gt;names&lt;/em&gt;, not just values) always have types, even if,
as in the “dynamic” languages, they're only implied – they only exist in the
programmer's&amp;nbsp;head, as assumptions on the value's&amp;nbsp;behavior.
If I&amp;nbsp;use a &lt;code&gt;startswith&lt;/code&gt; I&amp;nbsp;really want “a&amp;nbsp;method with the &lt;em&gt;semantics&lt;/em&gt; of &lt;code&gt;String:startswith&lt;/code&gt;”,
rather than “the method &lt;em&gt;named&lt;/em&gt;&amp;nbsp;startswith”.&lt;/p&gt;
&lt;h2 id="types-of-variables"&gt;Types of variables&lt;/h2&gt;
&lt;p&gt;I&amp;nbsp;have some syntax in mind. If I&amp;nbsp;rewrite one of the first examples in
Eevee's&amp;nbsp;post in it, I&amp;nbsp;can get something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;def foo(a: String, b: StringPattern, c: List):
    if a.startswith(b):
        c.append(a)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By which I&amp;nbsp;want to say &lt;code&gt;b&lt;/code&gt; can be string, or a&amp;nbsp;tuple of strings,
or even a&amp;nbsp;regex for all I&amp;nbsp;care – as long as it can be matched against a&amp;nbsp;string.
Those are the semantics I&amp;nbsp;wrote the function for.
If you call it with different types then you're on your own – it might work,
and the language should allow it, but I&amp;nbsp;offer no guarantees about the behavior of my&amp;nbsp;function.&lt;/p&gt;
&lt;p&gt;Here the “startswith” is, quite explicitly, &lt;code&gt;String:startswith&lt;/code&gt;.
The call is not a&amp;nbsp;command to “quack”, but to “quack &lt;em&gt;like a&amp;nbsp;duck&lt;/em&gt;”.&lt;/p&gt;
&lt;p&gt;The difference from statically-typed languages is that I'm not requiring &lt;code&gt;a&lt;/code&gt; to be
a&amp;nbsp;string, or a&amp;nbsp;string subtype.
I&amp;nbsp;don't even care if &lt;code&gt;a&lt;/code&gt; implements the string interface.
I'm just saying that I&amp;nbsp;want to call &lt;code&gt;String:startswith&lt;/code&gt;.
The &lt;code&gt;String&lt;/code&gt; declaration does not restrict the value, it provides a&amp;nbsp;namespace for my operations on it.
And with the namespaced operations come some well-defined semantics: if you misimplement them,
it's&amp;nbsp;not my fault that my &lt;code&gt;foo&lt;/code&gt; function won't&amp;nbsp;work.&lt;/p&gt;
&lt;p&gt;Similarly, I&amp;nbsp;don't care if &lt;code&gt;c&lt;/code&gt; is actually a&amp;nbsp;list. I'm just saying I&amp;nbsp;want the
&lt;code&gt;MutableSequence:append&lt;/code&gt; method (for which &lt;code&gt;List:append&lt;/code&gt; is an alias).
After the &lt;code&gt;append&lt;/code&gt; call, &lt;code&gt;c[-1]&lt;/code&gt; should be whatever I&amp;nbsp;just put there.
But that's&amp;nbsp;your (the caller's) problem. If &lt;code&gt;c&lt;/code&gt; is not &lt;code&gt;List&lt;/code&gt; enough,
your code might break with the next version of my&amp;nbsp;library.&lt;/p&gt;
&lt;p&gt;Of course, usually &lt;code&gt;a&lt;/code&gt; will be an “actual string”, and the compiler can
optimize for that case.&lt;/p&gt;
&lt;p&gt;I'll put a&amp;nbsp;random snippet with syntax ideas here:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;from somewhere import Snake

def print_length(x: List):
    print(x.length)

    if x has Snake:length:
        print(&amp;quot;Scary! I got a {}m long snake as argument!&amp;quot;(x.Snake:length))
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="type-declarations"&gt;Type declarations&lt;/h2&gt;
&lt;p&gt;For variables, the type can be specified declaration.
Python has no variable declarations, which I&amp;nbsp;don't think is healthy, because the
resulting scoping rules are not intuitive. They happen to work OK for 99%
of the cases, but when you get hit by the 1%, you don't even know where to look
(unless you remember the warning from your tutorial).
Javascript's&amp;nbsp;explicit &lt;code&gt;var&lt;/code&gt; keyword is a&amp;nbsp;good thing, for much the same reasons as Python's
explicit &lt;code&gt;self&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In my syntax, variable declarations can specify the type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;str: String = &amp;quot;abcd&amp;quot;

list: List = [1, 2, 3]

for i:int in list:
    print(i * i)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But, since most (or ideally all) expressions have a&amp;nbsp;well-defined types, a&amp;nbsp;shorthand comes to mind:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;str := &amp;quot;abcd&amp;quot;
list := [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="operator-namespaces"&gt;Operator namespaces&lt;/h2&gt;
&lt;p&gt;This would work:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;def concat(a: List, b: List):
    return a + b

def elementwise-add(a: Array, b: Array):
    return a + b

a := [1, 2, 3]
b := [4, 5, 6]

assert concat(a, b) == [1, 2, 3, 4, 5, 6]
assert elementwise-add(a, b) == [5, 7, 9]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;because while &lt;code&gt;Sequence:\+&lt;/code&gt; and &lt;code&gt;Array:\+&lt;/code&gt; are two different things,
lists can support &lt;em&gt;both&lt;/em&gt;.
(Here &lt;code&gt;List:\+&lt;/code&gt; is an alias for &lt;code&gt;Sequence:\+&lt;/code&gt; – a&amp;nbsp;List is primarily
a&amp;nbsp;Sequence.)&lt;/p&gt;
&lt;p&gt;(Extending this to custom operators with custom priority is left as an exercise...)&lt;/p&gt;
&lt;h2 id="definitions-and-implementations"&gt;Definitions and Implementations&lt;/h2&gt;
&lt;p&gt;Let's&amp;nbsp;make a&amp;nbsp;Tree interface.
I'll use &lt;a href="https://www.python.org/dev/peps/pep-0484/"&gt;PEP 484&lt;/a&gt;-ish syntax for generics:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;T := TypePlaceholder()

interface Tree:
    walk(self: T) -&amp;gt; Iterator[T]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This says that the type of &lt;code&gt;x.Tree:walk().next()&lt;/code&gt; will be the same as the
type of &lt;code&gt;x&lt;/code&gt;.
(For any &lt;code&gt;x&lt;/code&gt;. Remember it's&amp;nbsp;defining the type of the &lt;em&gt;expression&lt;/em&gt;, not the value;
it's&amp;nbsp;defining the namespace that expression will use by default.)&lt;/p&gt;
&lt;p&gt;Then you can define BinaryTree like this.
&lt;code&gt;BinaryTree:walk&lt;/code&gt; becomes an implementation of&amp;nbsp;&lt;code&gt;Tree:walk&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;class BinaryTree(Tree):
    left: Tree
    right: Tree

    impl walk(self):
        if self.left:
            yield from self.left.walk()
        yield self
        if self.right:
            yield from self.left.walk()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note the kewyord is &lt;code&gt;impl&lt;/code&gt;, not &lt;code&gt;def&lt;/code&gt;: this ensures that if the &lt;code&gt;Tree&lt;/code&gt; interface
grows a&amp;nbsp;new method, existing methods of the same name won't magically become
its implementations.
(Though you will get lots of &lt;em&gt;warnings&lt;/em&gt; about the new method not being implemented
by classes that claim to implement &lt;code&gt;Tree&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Next let's&amp;nbsp;have a&amp;nbsp;class for corporate employees.
An amployee is not a&amp;nbsp;tree, and there's&amp;nbsp;no &lt;code&gt;Employee:walk&lt;/code&gt; in our model,
but you can still use an employee as a&amp;nbsp;tree node:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;class Employee:
    boss: Employee
    underlings: List[Employee]

    impl Tree:walk(self):
        yield self
        for underling in self.underlings:
            yield from underling.walk()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And you might want to attach a &lt;code&gt;Tree:walk&lt;/code&gt; to something from some library you
can't easily change, like the stdlib.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;impl Path.Tree:walk(self):
    yield self
    if self.isdir:
        for child:Tree in self.listdir:
            yield from child
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The language should probably limit who can do this and where,&amp;nbsp;though.&lt;/p&gt;
&lt;p&gt;To step away from Tree for one paragraph:
Since every class derives from &lt;code&gt;Object&lt;/code&gt;, which has a &lt;code&gt;to_string&lt;/code&gt; method,
you can write &lt;code&gt;impl to_string&lt;/code&gt; in any class.
Or you can write &lt;code&gt;def to_string&lt;/code&gt;, which won't conflict with &lt;code&gt;Object:to_string&lt;/code&gt;
(though it will raise eyebrows and trip up your linter).
And you can later add &lt;code&gt;impl Object:to_string&lt;/code&gt;, which won't be aliased&amp;nbsp;to
&lt;code&gt;YourClass:to_string&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="interface-conflicts"&gt;Interface conflicts&lt;/h2&gt;
&lt;p&gt;Consider this class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;class FamilyMember:
    parents: List[FamilyMember]
    children: List[FamilyMember]

    impl Tree:walk(self):
        # this is not be correct but w/e
        yield self
        for child:Tree in self.children:
            yield from child
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, if you inherit from both &lt;code&gt;Employee&lt;/code&gt; and &lt;code&gt;FamilyMember&lt;/code&gt;, you're in trouble.
The resulting &lt;code&gt;Tree:walk&lt;/code&gt; should fail loudly, unless you explicitly override&amp;nbsp;it.&lt;/p&gt;
&lt;h2 id="bags-of-attributes"&gt;Bags of attributes&lt;/h2&gt;
&lt;p&gt;“But Petr“, I&amp;nbsp;hear you saying, “I&amp;nbsp;want my &lt;code&gt;getattr(self, 'visit_' + node.type)&lt;/code&gt;”!
Eh, really? I&amp;nbsp;reply. That looks quite ugly.
I&amp;nbsp;jut explained that I&amp;nbsp;think attribute names should &lt;em&gt;not&lt;/em&gt; be just names, didn't I?
If you want a&amp;nbsp;collection of things keyed by strings, use a&amp;nbsp;mapping.
You don't even want the keys to be strings here – you want Node&amp;nbsp;subclasses.&lt;/p&gt;
&lt;p&gt;That said, you could write &lt;code&gt;getattr(self, Attribute(Visit, node.type))&lt;/code&gt;,
and implement &lt;code&gt;Visit:leaf&lt;/code&gt;, where &lt;code&gt;Visit&lt;/code&gt; is an empty(!)&amp;nbsp;interface.&lt;/p&gt;
&lt;h2 id="thatsit-for-now"&gt;That's&amp;nbsp;it for now&lt;/h2&gt;
&lt;p&gt;I&amp;nbsp;could rant on, about, say, registration conflicts or efficient vtable
references, but let's&amp;nbsp;end it here, throw it at the wall and see if it&amp;nbsp;sticks.&lt;/p&gt;
&lt;p&gt;(I&amp;nbsp;welcome comments, by the way – if you have any, send them by e-mail or pull request)&lt;/p&gt;</summary><category term="language design"></category></entry></feed>